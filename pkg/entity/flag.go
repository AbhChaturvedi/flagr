//go:generate goqueryset -in flag.go

package entity

import (
	"fmt"
	"strings"

	"github.com/checkr/flagr/pkg/util"
	"github.com/jinzhu/gorm"
)

// Flag is the unit of flags
// gen:qs
type Flag struct {
	gorm.Model

	Key                string `gorm:"type:varchar(64);unique_index"`
	Description        string `sql:"type:text"`
	CreatedBy          string
	UpdatedBy          string
	Enabled            bool
	Segments           []Segment
	Variants           []Variant
	DataRecordsEnabled bool
	SnapshotID         uint `json:"-"`

	FlagEvaluation FlagEvaluation `gorm:"-" json:"-"`
}

// FlagEvaluation is a struct that holds the necessary info for evaluation
type FlagEvaluation struct {
	VariantsMap map[uint]*Variant
}

// BeforeCreate register a hook before create in gorm
func (f *Flag) BeforeCreate() error {
	if f.Key == "" {
		f.Key = util.NewSecureRandomKey()
	}
	return nil
}

// BeforeSave register a hook before create or update in gorm
func (f *Flag) BeforeSave() error {
	if f.Key != "" {
		ok, reason := util.IsSafeKey(f.Key)
		if !ok {
			return fmt.Errorf("cannot create flag due to invalid key. reason: %s", reason)
		}
	}
	return nil
}

// Preload preloads the segments and variants into flags
func (f *Flag) Preload(db *gorm.DB) error {
	ss := []Segment{}
	segmentQuery := NewSegmentQuerySet(db)
	if err := segmentQuery.FlagIDEq(f.ID).OrderAscByRank().OrderAscByID().All(&ss); err != nil {
		return err
	}
	for i, s := range ss {
		if err := s.Preload(db); err != nil {
			return err
		}
		ss[i] = s
	}
	f.Segments = ss

	vs := []Variant{}
	variantQuery := NewVariantQuerySet(db)
	err := variantQuery.FlagIDEq(f.ID).OrderAscByID().All(&vs)
	if err != nil {
		return err
	}
	f.Variants = vs
	return nil
}

// PrepareEvaluation prepares the information for evaluation
func (f *Flag) PrepareEvaluation() error {
	f.FlagEvaluation = FlagEvaluation{
		VariantsMap: make(map[uint]*Variant),
	}
	for i := range f.Segments {
		if err := f.Segments[i].PrepareEvaluation(); err != nil {
			return err
		}
	}
	for i := range f.Variants {
		f.FlagEvaluation.VariantsMap[f.Variants[i].ID] = &f.Variants[i]
	}
	return nil
}

// DescriptionLike patches the autogenerated queryset for find flags that
// partially match the description
func (qs FlagQuerySet) DescriptionLike(description string) FlagQuerySet {
	return qs.w(qs.db.Where(
		"lower(description) like ?",
		fmt.Sprintf("%%%s%%", strings.ToLower(description)),
	))
}
